## 1. 도메인(Domain)
**도메인(Domain)** 은 소프트웨어가 해결하고자 하는 **문제 영역**을 의미합니다. 예컨대 쇼핑몰, 은행 시스템, 병원 예약 시스템 등 구체적인 업무나 사업 영역이 도메인이 됩니다. DDD에서는 이 도메인을 깊이 이해하고, 소프트웨어에 적합한 형태로 모델링하여 **비즈니스 로직**을 올바르게 구현하는 것을 최우선으로 삼습니다.

---

## 2. Ubiquitous Language(보편 언어)
**Ubiquitous Language(보편 언어)** 는 **도메인 전문가(현업 담당자)** 와 **개발자** 사이의 소통에 사용되는 **공통 언어**를 말합니다.
- 예를 들어, “장바구니에 상품을 담는다”라는 도메인 용어를 코드 클래스나 메서드 이름에도 그대로 반영하여, 팀 전체가 **같은 개념과 용어로 의사소통**할 수 있도록 돕습니다.
- 이를 통해 서로 다른 직군 사이에서 용어 정의가 불분명해져 생길 수 있는 **지식 누락**이나 **오해**를 줄일 수 있습니다.

---

## 3. Bounded Context(경계 컨텍스트)
도메인이 커지면, 한꺼번에 모든 것을 처리하기 어렵습니다. 그래서 **의미가 구분되는 맥락**별로 나누어 관리하는데, 이를 **Bounded Context(경계 컨텍스트)** 라고 부릅니다.
- 예를 들어, 대형 쇼핑몰 시스템이라면 “상품 관리”, “주문”, “결제” 등으로 나눌 수 있습니다.
- 각 컨텍스트가 **독립적으로** 자체 모델을 유지하되, 필요한 경우에만 다른 컨텍스트와 **명확한 연동 규칙**을 정의합니다.
- 이를 통해 **불필요한 결합**을 피하고, 각 컨텍스트가 독립적으로 발전∙배포될 수 있도록 유연성을 확보합니다.

---

## 4. Entity, Value Object, Aggregate 등 핵심 개념

### 4.1. Entity(엔티티)
- **고유 식별자(ID)** 를 가지며, 해당 식별자를 통해 엔티티의 **생애 주기 전체를 추적**합니다.
- 예: “주문(Order)” 엔티티는 주문 ID로 식별되며, 주문 상태가 바뀌어도 ID가 유지됩니다.

### 4.2. Value Object(값 객체)
- 별도의 식별자가 없고, **값 자체**가 중요한 객체입니다.
- **불변성**을 강조하며, 값이 변경되면 새로운 Value Object로 대체하는 방식을 권장합니다.
- 예: “주소(Address)” 객체는 식별자보다 그 안의 지역, 도로명, 우편번호 등 **값** 자체가 중요합니다.

### 4.3. Aggregate(애그리거트)
- 서로 밀접하게 연관된 **엔티티와 값 객체의 집합**입니다.
- 해당 애그리거트의 **루트 엔티티(Aggregate Root)** 를 통해서만 외부에서 접근∙조작할 수 있도록 하여 일관성을 보장합니다.
- 예: “주문(Order)”과 “주문 항목(OrderLine)”들이 하나의 애그리거트를 이룹니다.

### 4.4. Domain Service(도메인 서비스)
- 특정 엔티티에 속하기 애매하지만, 여전히 **도메인 규칙** 에 해당하는 로직을 모아 둡니다.
- 예: 둘 이상의 애그리거트를 동시에 처리해야 할 경우, 별도의 Domain Service로 추상화하여 책임을 분리할 수 있습니다.

### 4.5. Repository(리포지토리)
- 엔티티나 애그리거트의 **저장∙조회∙삭제**를 책임지는 컴포넌트입니다.
- DDD에서는 Repository를 통해 도메인 객체를 조작하고, 내부적으로는 JPA나 MyBatis 등 구체적인 DB 기술을 사용합니다.

---

## 5. Context Mapping(맥락 맵핑)
**Bounded Context**가 여러 개 존재할 때, 각 컨텍스트 간 **협력 관계**와 **통신 방식**을 정의하는 것을 **Context Mapping**이라고 합니다.
- 예: “주문 컨텍스트”와 “결제 컨텍스트”가 서로 상호작용할 때, 데이터를 어떻게 넘겨주고 어떤 이벤트를 발생시킬지 정의합니다.
- 필요에 따라 **Anti-Corruption Layer**를 두어 외부 시스템∙컨텍스트와의 데이터 변환∙보호를 수행하거나, **Shared Kernel**로 공통 모델을 공유하는 식으로 모델 통합 방식을 결정합니다.

---

## 6. 도메인 이벤트(Domain Event), Event Storming 등
### 6.1. 도메인 이벤트(Domain Event)
- “주문이 생성되었다(OrderCreated)”, “결제가 완료되었다(PaymentCompleted)”처럼, **도메인 로직상 중요한 사건**을 이벤트 객체로 표현합니다.
- 이를 발행∙구독(pub/sub) 구조로 설계하면, 컨텍스트 간 **결합도를 낮추고**, **확장성**을 높일 수 있습니다.

### 6.2. Event Storming
- 도메인 전문가와 개발자가 함께 **시간 축(Time Line)** 순으로 도메인 이벤트를 시각화하여 분석∙설계하는 방법론입니다.
- 포스트잇 등을 활용한 시각화를 통해 **업무 흐름**, **핵심 시나리오**, **잠재적 문제** 등을 빠르게 파악할 수 있습니다.

---

## 7. Subdomain(하위 도메인)
- **Core Subdomain(핵심 하위 도메인)**: 프로젝트에서 가장 중요하고 경쟁력을 만드는 부분입니다. 에너지를 집중 투자해야 합니다.
- **Supporting Subdomain(지원 하위 도메인)**: 핵심을 보조하는 로직이나 기능입니다.
- **Generic Subdomain(범용 하위 도메인)**: 보편적인 기능 예: 결제 모듈, 이메일 전송 등. 필요하다면 제3자 솔루션을 활용하기도 합니다.

DDD는 **핵심 도메인**에 더 많은 시간을 투자해 비즈니스 가치를 최대화하고, 나머지 부분은 효율적으로 구성해 전체 생산성을 높이는 전략을 지향합니다.

---

## 8. DDD가 추구하는 목표 및 장점

1. **복잡한 비즈니스 요구사항에 대한 체계적 접근**
   - 핵심적인 문제를 해결하기 위해 도메인을 구조적으로 이해하고, 변화 요구에 대응하기 쉽도록 만듭니다.

2. **팀 간 원활한 소통**
   - Ubiquitous Language를 통해 도메인 전문가와 개발자 간 **용어와 개념**이 일치하도록 돕습니다.

3. **올바른 추상화와 캡슐화**
   - Aggregate 등을 사용하여 핵심 로직을 감싸고, 불필요한 외부 접근을 제한함으로써 **유지보수**가 쉬워집니다.

4. **확장성과 유연성**
   - Bounded Context를 적절히 분리하고, Context Mapping을 통해 **컨텍스트 간 결합도**를 줄여 나갑니다.

---

### 결론
도메인 주도 설계(DDD)는, **도메인 모델**이 개발 과정 전체에서 최우선이 되도록 하여 복잡한 비즈니스 로직을 **정확**하고 **유지보수 가능**하게 만드는 방법론입니다.  
도메인 전문가와 개발자가 **공통 언어**로 끊임없이 소통하면서, **도메인 핵심 가치를 소프트웨어에 반영**하려는 노력이 DDD의 근본이라 할 수 있습니다.